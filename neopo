#!/usr/bin/env python3

# neopo: A replacement for po-util
# Copyright (c) 2020 - Nathan Robinson

import json
import zipfile
import io
import gzip
import tarfile
import platform
import stat
import os
import pathlib
import sys
import subprocess
import shutil
import urllib.request

if platform.system().lower() not in ['darwin', 'linux']:
    exit('OS is not supported! Use Linux or macOS.')

# Global Variables
DEPS = os.environ['HOME'] + '/.particle/toolchains'


# Find the Workbench extension URL from the Visual Studio Marketplace 
def getExtensionURL():
    print("Finding Workbench extension URL...")

    payload = '{"assetTypes":null,"filters":[{"criteria":[{"filterType":7,"value":"particle.particle-vscode-core"}],"direction":2,"pageSize":100,"pageNumber":1,"sortBy":0,"sortOrder":0,"pagingToken":null}],"flags":103}'

    request = urllib.request.Request('https://marketplace.visualstudio.com/_apis/public/gallery/extensionquery', method='POST', headers={
        'content-type': 'application/json',
        'accept': 'application/json;api-version=6.0-preview.1;excludeUrls=true'
    }, data=payload.encode('utf-8'))

    with urllib.request.urlopen(request) as response:
        content = response.read()
    
    data = json.loads(content.decode('utf-8'))
    latest = data['results'][0]['extensions'][0]['versions'][0]['files'][-1]['source']

    return latest

# Download the the Workbench extension from the URL
def getExtension(url):
    print("Downloading Workbench extension...")

    with urllib.request.urlopen(url) as response:
        content = response.read()

    return zipfile.ZipFile(io.BytesIO(content), 'r')

# Load a file from a ZIP
def getFile(file, path):
    content = file.read(path)
    return content

# Download a dependency specified by the JSON
def downloadDep(dep):
    writeManifest(dep)
    name = dep['name']
    version = dep['version']

    print("Downloading dependency " + name + " version " + version + "...")

    path = name + '/' + version
    path = DEPS + '/' + path
    url = dep['url']

    with urllib.request.urlopen(url) as response:
        content = response.read()

    data = gzip.decompress(content)

    with tarfile.TarFile(None, 'r', io.BytesIO(data)) as file:
        file.extractall(path)

    return response

# Write JSON data to a file
def writeFile(content, path):
    with open(path, 'w') as file:
        file.write(content)

# Write an executable dependency to a file
def writeExecutable(content, path):
    with open(path, 'wb') as file:
        file.write(content)
        st = os.stat(file.name)
        os.chmod(file.name, st.st_mode | stat.S_IEXEC)

# Download extension manifest and simple dependencies
def getDeps():
    osPlatform = platform.system().lower()
    osArch = 'amd64' if platform.machine() == 'x86_64' else 'arm'

    url = getExtensionURL()
    extension = getExtension(url)

    pathlib.Path(DEPS + '/vscode/').mkdir(parents=True, exist_ok=True)

    manifest = getFile(extension, 'extension/src/compiler/manifest.json')
    particle = getFile(extension, 'extension/src/cli/bin/' +
                       osPlatform + '/' + osArch + '/particle')

    launch = getFile(
        extension, 'extension/src/cli/vscode/launch.json').decode('utf-8')
    settings = getFile(
        extension, 'extension/src/cli/vscode/settings.json').decode('utf-8')

    writeFile(launch, DEPS + '/vscode/launch.json')
    writeFile(settings, DEPS + '/vscode/settings.json')

    writeExecutable(particle, DEPS + '/particle')

    data = json.loads(manifest.decode('utf-8'))
    return data

# Write the settings to a JSON file
def writeManifest(dep):
    with open(DEPS + '/manifest.json', 'r+') as file:
        try:
            manifest = json.loads(file.read())
        except json.decoder.JSONDecodeError:
            manifest = {}

        manifest[dep['name']] = dep['version']
        file.seek(0)
        json.dump(manifest, file, indent=4)
        file.truncate()

# Create the settings file
def createManifest():
    with open(DEPS + '/manifest.json', 'w') as file:
        pass

# Load settings from the JSON file
def loadManifest():
    with open(DEPS + '/manifest.json', 'r') as file:
        return json.loads(file.read())

# Download list of dependencies and install them
def install():
    print("Installing neopo...")
    osPlatform = platform.system().lower()
    data = getDeps()
    firmware = data['firmware'][0]
    compilers = data['compilers'][osPlatform]['x64'][0]
    tools = data['tools'][osPlatform]['x64'][0]
    scripts = data['scripts'][osPlatform]['x64'][0]
    debuggers = data['debuggers'][osPlatform]['x64'][0]

    createManifest()
    downloadDep(firmware)
    downloadDep(compilers)
    downloadDep(tools)
    downloadDep(scripts)
    downloadDep(debuggers)

# Create a Particle project and copy in Workbench settings
def create(path, name):
    tempEnv = os.environ.copy()
    tempEnv['PATH'] += ':' + DEPS

    subprocess.run(['particle', 'project', 'create',
                    path, '--name', name], env=tempEnv)
    pathlib.Path(path + '/' + name +
                 '/.vscode/').mkdir(parents=True, exist_ok=True)

    shutil.copyfile(DEPS + '/vscode/launch.json', path +
                    '/' + name + '/.vscode/launch.json')
    shutil.copyfile(DEPS + '/vscode/settings.json', path +
                    '/' + name + '/.vscode/settings.json')
    

    manifest = loadManifest()
    device = 'argon'
    configure(path + '/' + name, device, manifest['deviceOS'])

# Modify Workbench settings in a project (platform, firmwareVersion)
# TODO: Input verification, install specified firmware if required
def configure(projectPath, platform, firmwareVersion):
    with open(projectPath + '/.vscode/settings.json', 'r+') as settings:
        data = json.loads(settings.read())
        data['particle.targetPlatform'] = platform
        data['particle.firmwareVersion'] = firmwareVersion
        settings.seek(0)
        json.dump(data, settings, indent=4)
        settings.truncate()
    print("Configured project " + projectPath + ':')
    print("\tparticle.targetPlatform: " + platform)
    print("\tparticle.firmwareVersion: " + firmwareVersion)

# Load Workbench settings from a project
def getSettings(projectPath):
    with open(projectPath + '/.vscode/settings.json', 'r+') as settings:
        return json.loads(settings.read())

# Print help information directly from Makefile
def build_help():
    manifest = loadManifest()
    compilerVersion = manifest['gcc-arm']
    scriptVersion = manifest['buildscripts']
    toolsVersion = manifest['buildtools']
    firmwareVersion = manifest['deviceOS']

    tempEnv = os.environ.copy()
    tempEnv['PATH'] += ':' + DEPS + '/gcc-arm/' + compilerVersion + '/bin'
    tempEnv['PATH'] += ':' + DEPS + '/buildtools/' + toolsVersion

    process = ['make', '-sf', DEPS + '/buildscripts/' + scriptVersion + '/Makefile',
               'PARTICLE_CLI_PATH=' + DEPS + '/particle', 'DEVICE_OS_PATH=' +
               DEPS + '/deviceOS/' + firmwareVersion, 'help'
               ]

    subprocess.run(process, env=tempEnv)

# Use the Makefile to build the specified target
def build(projectPath, command):
    manifest = loadManifest()
    compilerVersion = manifest['gcc-arm']
    scriptVersion = manifest['buildscripts']
    toolsVersion = manifest['buildtools']

    tempEnv = os.environ.copy()
    tempEnv['PATH'] += ':' + DEPS + '/gcc-arm/' + compilerVersion + '/bin'
    tempEnv['PATH'] += ':' + DEPS + '/buildtools/' + toolsVersion

    settings = getSettings(projectPath)
    platform = settings['particle.targetPlatform']
    firmwareVersion = settings['particle.firmwareVersion']

    process = ['make', '-sf', DEPS + '/buildscripts/' + scriptVersion + '/Makefile',
               'PARTICLE_CLI_PATH=' + DEPS + '/particle', 'DEVICE_OS_PATH=' +
               DEPS + '/deviceOS/' + firmwareVersion,
               'PLATFORM=' + platform, 'APPDIR=' + projectPath, command
               ]

    #print(process)

    subprocess.run(process, env=tempEnv)

# Print help information about the program
def print_help():
    print("""Usage: neopo [OPTIONS] PROJECT

Options:
    General Options:
        help
        install
        create <project>

    Build Options:
        compile, build <project>
        flash <project>
        flash-all <project>
        clean <project>

    Special Options:
        run <target> <project>
        configure <platform> <version> <project>
        """)

# Parse the project path from the specified index and run a Makefile target
def buildCommand(command, index):
    try:
        project = os.environ['PWD'] + '/' + sys.argv[index]
    except IndexError:
        project = os.environ['PWD']

    try:
        build(project, command)
    except FileNotFoundError:
        print("Invalid project!")

# Evaluate command-line arguments and call neccesary functions
def main():
    # print(sys.argv)

    if len(sys.argv) == 1 or sys.argv[1] == 'help':
        print_help()
        return

    if sys.argv[1] == 'install':
        install()
        return

    if sys.argv[1] == 'create':
        try:
            projectPath = sys.argv[2]
        except IndexError:
            print("You must supply a path for the project!")
            return

        projectPath = os.path.abspath(projectPath)
        name = os.path.basename(projectPath)
        path = os.path.dirname(projectPath)
        create(path, name)
        return

    if sys.argv[1] == 'compile' or sys.argv[1] == 'build':
        buildCommand('compile-user', 2)
        return

    if sys.argv[1] == 'flash':
        buildCommand('flash-user', 2)
        return

    if sys.argv[1] == 'flash-all':
        buildCommand('flash-all', 2)
        return

    if sys.argv[1] == 'clean':
        buildCommand('clean-user', 2)
        return

    if sys.argv[1] == 'run':
        try:
            command = sys.argv[2]
        except IndexError:
            build_help()
            print("You must supply a Makefile target!")
            return

        buildCommand(command, 3)
        return

    if sys.argv[1] == 'configure':
        try:
            platform = sys.argv[2]
            version = sys.argv[3]
        except IndexError:
            print("You must supply platform and deviceOS version!")
            return
        
        try:
            projectPath = sys.argv[4]
        except IndexError:
            projectPath = os.environ['PWD']
        
        configure(projectPath, platform, version)
        return

    print("Invalid command!")
    print_help()


if __name__ == "__main__":
    main()
